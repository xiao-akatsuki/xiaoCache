package com.xiaoCache.cache.simple;


import java.io.File;
import java.io.FileWriter;
import java.io.Serializable;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import com.xiaoCache.cache.simple.method.CacheFun;



/**
 * [简单缓存](Simple cache)
 * @description zh - 简单缓存
 * @description en - Simple cache
 * @version V1.0
 * @author XiaoXunYao
 * @since 2021-09-20 11:26:51
 */
public class SimpleCache<K, V> implements Iterable<Map.Entry<K, V>>, Serializable {
    
    
    private static final long serialVersionUID = 1L;

    /**
     * 池
     */
    private  volatile  Map<K, V> cache;

    /**
     * 乐观读写锁
     */
    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    /**
     * 写的时候每个key一把锁，降低锁的粒度
     */
    protected final Map<K, Lock> keyLockMap = new ConcurrentHashMap<>();

    /**
     * 设置超时时间
     */
    private final Map<K,Long> TimeOutMap=new HashMap<>();

    /**
     * 设置超时
     */
    private static final Timer timer=new Timer();

    /**
     * [内部类]
     * @description zh - 构建TimerTask
     * @description en - 
     * @version V1.0
     * @author drh
     * @since 2021-10-17 9:00 
     */    
    class SimpleCacheTimer extends TimerTask{
        private K key;
        public SimpleCacheTimer(K key){
            this.key=key;
        }
        @Override
        public void run() {
            // TODO Auto-generated method stub
             cache.remove(key);
        }

    }

    /**
     * [构造](structure)
     * @description zh - 构造
     * @description en - structure
     * @version V1.0
     * @author drh
     * @since 2021-10-17 8:57
     */
    public SimpleCache() {
        if(null==cache){
            synchronized(this){
                if(null==cache){
                    cache=new ConcurrentHashMap<>();
                }
            }
        }
    }

    /**
     * [通过自定义Map初始化，可以自定义缓存实现。](Through the custom map initialization, you can customize the cache implementation.)
     * @description: zh - 通过自定义Map初始化，可以自定义缓存实现。
     * @description: en - Through the custom map initialization, you can customize the cache implementation.
     * @version: V1.0
     * @author XiaoXunYao
     * @since 2021-09-20 11:22:50
     * @param initMap: 初始Map，用于定义Map类型
    */
    public SimpleCache(Map<K, V> initMap) {
        this.cache = initMap;
    }

    /**
     * [从缓存池中查找值](Find value from cache pool)
     * @description: zh - 从缓存池中查找值
     * @description: en - Find value from cache pool
     * @version: V1.0
     * @author XiaoXunYao
     * @since 2021-09-20 11:23:03
     * @param key: 键
     * @return V
    */
    public  V get(K key){
        lock.readLock().lock();
        try {
            return cache.get(key);
        }finally {
            lock.readLock().unlock();
        }
    }

    /**
     * [从缓存中获得对象，当对象不在缓存中或已经过期返回回调产生的对象](Get the object from the cache. When the object is not in the cache or has expired, return the object generated by the callback)
     * @description: zh - 从缓存中获得对象，当对象不在缓存中或已经过期返回回调产生的对象
     * @description: en - Get the object from the cache. When the object is not in the cache or has expired, return the object generated by the callback
     * @version: V1.0
     * @author XiaoXunYao
     * @since 2021-09-20 11:23:15
     * @param key: 键
     * @param supplier: 如果不存在回调方法，用于生产值对象
     * @return V
    */
    public V get(K key, CacheFun<V> supplier){
        V v = get(key);
        if(null == v && null != supplier) {
            //每个key单独获取一把锁，降低锁的粒度提高并发能力，see pr#1385@Github
            final Lock keyLock = keyLockMap.computeIfAbsent(key, k -> new ReentrantLock());
            keyLock.lock();
            try {
                // 双重检查，防止在竞争锁的过程中已经有其它线程写入
                v = cache.get(key);
                if (null == v) {
                    try {
                        v = supplier.call();
                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }
                    put(key, v);
                }
            } finally {
                keyLock.unlock();
                keyLockMap.remove(key);
            }
        }
        return v;
    }

    /**
     * [存入缓存](Cache)
     * @description: zh - 存入缓存
     * @description: en - Cache
     * @version: V1.0
     * @author XiaoXunYao
     * @since 2021-09-20 11:23:28
     * @param key: 键
     * @param value: 值
     * @return V
    */
    public V put(K key, V value) {
        // 独占写锁
        lock.writeLock().lock();
        try {
            cache.put(key, value);
        } finally {
            lock.writeLock().unlock();
        }
        return value;
    }

    /**
     * [存入缓存](Cache)
     * @description: zh - 存入缓存并设置过期时间
     * @description: en - Store in cache and set expiration time
     * @version: V1.0
     * @author drh
     * @since 2021-10-17 9:54
     * @param key: 键
     * @param value: 值
     * @return V
    */
    public V put(K key,V value,Long timeOut){
        this.cache.put(key, value);
        timer.schedule(new SimpleCacheTimer(key),timeOut);
        this.TimeOutMap.put(key,System.currentTimeMillis()+timeOut);
        return value;
    }

    /**
     * [移除缓存](Remove cache)
     * @description: zh - 移除缓存
     * @description: en - Remove cache
     * @version: V1.0
     * @author XiaoXunYao
     * @since 2021-09-20 11:23:39
     * @param key: 键
     * @return V
    */
    public V remove(K key) {
        // 独占写锁
        lock.writeLock().lock();
        try {
            return cache.remove(key);
        } finally {
            lock.writeLock().unlock();
        }
    }

    /**
     * [清空缓存池](Clear cache pool)
     * @description: zh - 清空缓存池
     * @description: en - Clear cache pool
     * @version: V1.0
     * @author XiaoXunYao
     * @since 2021-09-20 11:23:51
    */
    public void clear() {
        // 独占写锁
        lock.writeLock().lock();
        try {
            this.cache.clear();
        } finally {
            lock.writeLock().unlock();
        }
    }

    /**
     * [重写迭代器](Override iterator)
     * @description: zh - 重写迭代器
     * @description: en - Override iterator
     * @version: V1.0
     * @author XiaoXunYao
     * @since 2021-09-20 11:24:02
     * @return java.util.Iterator<java.util.Map.Entry<K,V>>
    */
    @Override
    public Iterator<Map.Entry<K, V>> iterator() {
        return this.cache.entrySet().iterator();
    }


    /**
     * @author drh
     * @description  zh - 判断Key中的值是否为空，如果不存在返回true，存在返回false
     * @description en - Judge whether the value in Key is empty, return true if it does not exist, return false if it exists
     * @date 1:14 下午 2021/9/20
     * @version: V1.0
     * @param [key]
     * @return java.lang.Boolean
     **/
    public Boolean isNull(K key){
        return null == get(key);
    }

    /**
     * @author drh
     * @description zh - 判断缓存中是否存在key，存在返回true，不存在返回false
     * @description en - Determine whether there is a key in the cache, return true if it exists, return false if it does not exist
     * @date 1:22 下午 2021/9/20
     * @param [key]
     * @return java.lang.Boolean
     **/
    public Boolean hasKey(K key){
        return this.cache.containsKey(key);
    }

    /**
     * @author drh
     * @description zh - 获取缓存数量
     * @description en - Get the buffer number
     * @date 3:25 下午 2021/9/20
     * @param []
     * @return java.lang.Integer
     **/
    public Integer length(){
        return this.cache.size();
    }

    /**
     * @author drh
     * @description  zh - 替换数组中的value值
     * @description  en - Replace the value in the array
     * @date 7:40 上午 2021/9/21
     * @param [key, value]
     * @return V
     **/
    public V replace(K key,V value){
        this.cache.replace(key,value);
        return value;
    }

    /**
     * @description zh - 获取缓存中的所有值
     * @description en - Get all the values in the cache
     * @author drh
     * @date 8:07 上午 2021/9/21
     * @return java.util.List<V>
     **/
    public List<V> getAll(){
        Iterator<Map.Entry<K, V>> iterator = iterator();
        CopyOnWriteArrayList list=new CopyOnWriteArrayList<>();
        while(iterator.hasNext()){
            list.add(iterator.next());
        }
        return list;
    }
    /**
     * @author drh
     * @description zh - 设置超时时间
     * @description en - Set timeout
     * @date 12:18 下午 2021/9/21
     * @param [key, value, time]
     * @return V
     **/
    public K setInvalidationTime(K key,long time){
        if (key==null){
            return null;
        }
        put(key,cache.get(key),time);
        this.TimeOutMap.put(key,System.currentTimeMillis()+time);
        
        return key;
    }
   
    /**
     * @author drh
     * @description zh - 判断缓存是否超时,true未过期，false为未过期
     * @description en - Judge whether the cache timeout, true is not expired, false is not expired
     * @date 12:21 下午 2021/9/21
     * @param [key]
     * @return k
     **/
    public Boolean isTimeOut(K key){
        if (key==null){
             try {
                throw new Exception("key未null");
            } catch (Exception e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        Long time = this.TimeOutMap.get(key);
        if (time==null) {
            try {
                throw new Exception("未设置超时时长");
            } catch (Exception e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        System.out.println(1);
        if (System.currentTimeMillis()>time){
            this.TimeOutMap.remove(key);
            this.cache.remove(key);
            return true;
        }
        return false;
    }
    


    /**
     * @author drh
     * @description zh - 获取过期剩余时间
     * @description en - Get the remaining time after expiration
     * @date 1:04 下午 2021/9/22
     * @param [key]
     * @return java.lang.Long
     **/
    public Long TimeLeft(K key){
        return  TimeOutMap.get(key) == null ? null : TimeOutMap.get(key)-System.currentTimeMillis();

    }

    /**
     * @author drh
     * @description zh - 获取value值的长度
     * @description en - Get the length of value
     * @date 4:08 下午 2021/9/21
     * @param [key]
     * @return java.lang.Integer
     **/
    public Integer getValueSize(K key){
        return ((String)this.get(key)).getBytes().length;
    }

    /**
     * @author drh
     * @description zh - 获取多个key的对应值
     * @description en - Get the corresponding value of multiple keys
     * @date 8:08 上午 2021/9/22
     * @param [key]
     * @return java.util.List<V>
     **/
    public List<V> getValues(K... key){
        CopyOnWriteArrayList list=new CopyOnWriteArrayList<>();
        for (K k:key){
            list.add(get(k));
        }

        return list;
    }

    /**
     * @author drh
     * @description zh - 将 key 中储存的数字值减一
     * @description en - Decrease the numeric value stored in key by on
     * @date 10:00 上午 2021/9/22
     * @param
     * @return
     **/
    public V Decr(K key){
        if (get(key) instanceof Number){
            int v= ((Number) get(key)).intValue()-1;
            put(key,(V)(Object)v);
            return (V)(Object)v;
        }
        return null;
    }

    /**
     * @author drh
     * @description zh - 将 key 中储存的数字值加一
     * @description en - Add one to the numeric value stored in key
     * @date 10:00 上午 2021/9/22
     * @param
     * @return
     **/
    public V Incr(K key){
        if (get(key) instanceof Number){
            int v= ((Number) get(key)).intValue()+1;
            put(key,(V)(Object)v);
            return (V)(Object)v;
        }
        return null;
    }

    /**
     * @author drh
     * @description zh - 将 key 中储存的数字值加任意整型
     * @description en - Decrease the numeric value stored in key by on
     * @date 10:00 上午 2021/9/22
     * @param
     * @return
     **/
    public V IncrInt(K key,Integer i){
        if (get(key) instanceof Number){
            int v= ((Number) get(key)).intValue()+i;
            put(key,(V)(Object)v);
            return (V)(Object)v;
        }
        return null;
    }

    /**
     * @author drh
     * @description zh - 将 key 中储存的数字值加任意浮点数
     * @description en - Add any floating point number to the numeric value stored in the key
     * @date 10:00 上午 2021/9/22
     * @param
     * @return
     **/
    public V IncrFlot(K key,Float i){
        if (get(key) instanceof Number){
            float v= ((Number) get(key)).floatValue()+i;
            put(key,(V)(Object)v);
            return (V)(Object)v;
        }
        return null;
    }
    
    /**
     * @author drh
     * @description zh - 获取value的类型
     * @description en - Get the type of value
     * @date 1:29 下午 2021/10/11
     * @param
     * @return
     **/
    public V getType(K key){
        return (V) get(key).getClass();
    }

    /**
     * @author drh
     * @description zh - 重命名key
     * @description en - rename key
     * @date 2:22 下午 2021/10/11
     * @param
     * @return
     **/
    public K Rename(K key,K newKey) throws Exception{
        if(hasKey(key)){
           throw new Exception("error: key is null");
        }
        put(newKey, get(key));
        remove(key);
        return newKey;
    }

    /**
     * @author drh
     * @description zh - 获取缓存中的所有key值
     * @description en - Get all the key values in the cache
     * @date 2:31 下午 2021/10/11
     * @param
     * @return
     **/
    public Set getKeys(){
        return this.cache.keySet();
    }
    /**
     * @author drh
     * @description zh - 导出缓存数据，需要在创建Simple Cache时传入Map的实例化对象,默认的weakHashMap无法序列化
     * @description en - To export cache data, you need to pass in the instantiated object of Map when creating Simple Cache, the default weakHashMap cannot be serialized
     * @date 2:31 下午 2021/10/11
     * @param
     * @return
     **/
    public void Export(String ExportPath){
       StringBuffer stringBuffer=new StringBuffer();
       ArrayList list=new ArrayList<>(getKeys());
       for(int i=0;i<list.size();i++){
           stringBuffer.append("key"+list.get(i)+"value"+this.cache.get(list.get(i))+",");
       }
       try {
        File file=new File(ExportPath);
        FileWriter fw=new FileWriter(file);
        fw.write(String.valueOf(stringBuffer));
        fw.close();    
       } catch (Exception e) {
           //TODO: handle exception
           e.printStackTrace();
       }
       
    }

    
}
